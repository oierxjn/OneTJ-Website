---
title: 架构设计
date: 2025-01-29 00:00:00
permalink: /guide/architecture
categories:
  - 指南
tags:
  - 指南
  - 架构
description: 介绍 OneTJ 的 MVVM 架构设计。
---

## MVVM 架构

OneTJ 采用 **MVVM (Model-View-ViewModel)** 架构模式，这是一种清晰的分层架构，有助于分离关注点并提高代码可维护性。

### 架构分层

```
┌─────────────────────────────────────────────────────────┐
│                       View (视图层)                      │
│           UI 组件、Widget、用户交互界面                   │
└────────────────────┬────────────────────────────────────┘
                     │ 绑定
                     ↓
┌─────────────────────────────────────────────────────────┐
│                   ViewModel (视图模型)                   │
│           业务逻辑、状态管理、数据转换                    │
└────────────────────┬────────────────────────────────────┘
                     │ 获取
                     ↓
┌─────────────────────────────────────────────────────────┐
│                    Model (数据层)                       │
│         数据模型、Repository、Service API                │
└─────────────────────────────────────────────────────────┘
```

## 各层职责

### Model（数据层）

**职责**：管理数据，不包含任何 UI 相关逻辑。

**组成**：

- **数据模型** (`models/`)：定义数据结构
- **Repository** (`repo/`)：管理本地缓存
- **Service** (`services/`)：调用外部 API

**示例**：

```dart
// 数据模型
class StudentInfoData {
  final String name;
  final String userId;
  // ...
}

// Repository
class StudentInfoRepository {
  Future<StudentInfoData?> getStudentInfo() async {
    // 从 Hive 缓存读取
  }
  Future<void> saveStudentInfo(StudentInfoData data) async {
    // 保存到 Hive 缓存
  }
}

// Service
class TongjiApi {
  Future<StudentInfoData> fetchStudentInfo() async {
    // 调用 API 获取数据
  }
}
```

### ViewModel（视图模型）

**职责**：连接 Model 和 View，处理视图的业务逻辑。

**特点**：

- 继承自 `BaseViewModel`
- 使用 `StreamController` 向 View 发送数据更新
- 处理用户交互，调用 Model 层方法
- 不包含任何 UI 代码

**示例**：

```dart
class HomeViewModel extends BaseViewModel {
  final StreamController<String> _studentInfoController =
      StreamController<String>.broadcast();

  Stream<String> get studentInfo => _studentInfoController.stream;

  Future<void> loadStudentInfo() async {
    try {
      // 调用 Model 层获取数据
      final data = await _model.fetchStudentInfo();
      // 通过 Stream 发送数据更新
      _studentInfoController.add("姓名：${data.name}");
    } catch (error) {
      // 错误处理
    }
  }
}
```

### View（视图层）

**职责**：渲染 UI，响应用户交互。

**特点**：

- 使用 `StatefulWidget` 或 `StatelessWidget`
- 通过 `StreamBuilder` 或 `StreamSubscription` 监听 ViewModel 的数据变化
- 将用户交互委托给 ViewModel

**示例**：

```dart
class DashboardView extends StatefulWidget {
  @override
  _DashboardViewState createState() => _DashboardViewState();
}

class _DashboardViewState extends State<DashboardView> {
  late HomeViewModel _viewModel;
  StreamSubscription<String>? _infoSub;

  @override
  void initState() {
    super.initState();
    _viewModel = HomeViewModel();
    _infoSub = _viewModel.studentInfo.listen((data) {
      setState(() {
        // 更新 UI
      });
    });
    _viewModel.loadStudentInfo();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: StreamBuilder<String>(
        stream: _viewModel.studentInfo,
        builder: (context, snapshot) {
          return Text(snapshot.data ?? 'Loading...');
        },
      ),
    );
  }
}
```

## 数据流向

```
用户操作 → View → ViewModel → Service API
                      ↓
                 Repository (缓存)
                      ↓
                     Model
                      ↓
              ViewModel (转换数据)
                      ↓
                     View (更新 UI)
```

## 路由设计

使用 `go_router` 进行声明式路由管理：

```dart
class AppRouter {
  static final GoRouter router = GoRouter(
    routes: [
      GoRoute(
        path: '/',
        builder: (context, state) => const LauncherView(),
      ),
      GoRoute(
        path: '/login',
        builder: (context, state) => const LoginView(),
      ),
      ShellRoute(
        builder: (context, state, child) => HomeView(child: child),
        routes: [
          GoRoute(
            path: '/dashboard',
            builder: (context, state) => const DashboardView(),
          ),
          // ...
        ],
      ),
    ],
  );
}
```

## 状态管理

OneTJ 使用 **Stream + StatefulWidget** 进行状态管理：

1. ViewModel 使用 `StreamController` 发送状态更新
2. View 使用 `StreamBuilder` 或 `StreamSubscription` 监听状态
3. 状态变化时自动更新 UI

## 依赖注入

采用 **Repository 单例模式**：

```dart
class StudentInfoRepository {
  StudentInfoRepository._();
  static final StudentInfoRepository _instance = StudentInfoRepository._();
  factory StudentInfoRepository.getInstance() => _instance;
}
```

## 架构优势

| 优势 | 说明 |
|------|------|
| **低耦合** | 各层职责清晰，互不干扰 |
| **可测试** | ViewModel 和 Model 可以独立测试 |
| **可维护** | 修改 UI 不影响业务逻辑 |
| **可复用** | Model 和 ViewModel 可在不同 View 中复用 |
