---
title: ViewModel 开发指南
date: 2025-01-29 00:00:00
permalink: /develop/guide/viewmodel
categories:
  - 开发
tags:
  - 开发
  - ViewModel
description: 介绍 OneTJ 项目的 ViewModel 开发规范。
---

## ViewModel 概述

在 OneTJ 的 MVVM 架构中，ViewModel 是连接 Model 和 View 的中间层，负责处理视图的业务逻辑。

## BaseViewModel

所有 ViewModel 应继承自 `BaseViewModel`：

```dart
// lib/models/base_model.dart
abstract class BaseViewModel {
  void dispose() {
    // 子类实现资源释放
  }
}
```

## ViewModel 结构

### 基本结构

```dart
class MyViewModel extends BaseViewModel {
  // 1. 私有模型
  final MyModel _model;

  // 2. Stream 控制器
  final StreamController<MyData> _dataController =
      StreamController<MyData>.broadcast();
  final StreamController<Object> _errorController =
      StreamController<Object>.broadcast();

  // 3. 公开 Stream
  Stream<MyData> get data => _dataController.stream;
  Stream<Object> get errors => _errorController.stream;

  // 4. 构造函数
  MyViewModel({MyModel? model})
      : _model = model ?? MyModel();

  // 5. 业务方法
  Future<void> loadData() async {
    try {
      final result = await _model.fetchData();
      _dataController.add(result);
    } catch (error) {
      _errorController.add(error);
    }
  }

  // 6. 资源释放
  @override
  void dispose() {
    _dataController.close();
    _errorController.close();
    super.dispose();
  }
}
```

## Stream 使用

### StreamController

使用 `StreamController.broadcast()` 创建多订阅 Stream：

```dart
class MyViewModel extends BaseViewModel {
  final StreamController<String> _messageController =
      StreamController<String>.broadcast();

  Stream<String> get messages => _messageController.stream;

  void sendMessage(String message) {
    _messageController.add(message);
  }

  @override
  void dispose() {
    _messageController.close();
    super.dispose();
  }
}
```

### 事件模型

使用 `Stream<UiEvent>` 发送 UI 事件：

```dart
// lib/models/event_model.dart
abstract class UiEvent {}

class NavigateEvent extends UiEvent {
  final String path;
  const NavigateEvent(this.path);
}

class ShowSnackBarEvent extends UiEvent {
  final String message;
  final String? code;
  const ShowSnackBarEvent({required this.message, this.code});
}

// 在 ViewModel 中使用
class LoginViewModel extends BaseViewModel {
  final StreamController<UiEvent> _eventController =
      StreamController<UiEvent>.broadcast();

  Stream<UiEvent> get events => _eventController.stream;

  void handleLoginSuccess() {
    _eventController.add(const NavigateEvent('/home'));
  }

  void handleError(String message) {
    _eventController.add(ShowSnackBarEvent(message: message));
  }
}
```

## 错误处理

### Try-Catch 模式

```dart
Future<void> loadData() async {
  try {
    final result = await _model.fetchData();
    _dataController.add(result);
    _errorController.add(null); // 清除错误状态
  } on AppException catch (e) {
    _errorController.add(e);
    _eventController.add(
      ShowSnackBarEvent(message: e.message, code: e.code),
    );
  } catch (e) {
    _errorController.add(e);
    _eventController.add(
      ShowSnackBarEvent(message: '未知错误'),
    );
  }
}
```

### 错误状态

```dart
class MyViewModel extends BaseViewModel {
  // 数据 Stream
  final StreamController<MyData> _dataController = ...;
  // 加载状态 Stream
  final StreamController<bool> _loadingController = ...;
  // 错误 Stream
  final StreamController<Object?> _errorController = ...;

  Stream<bool> get isLoading => _loadingController.stream;
  Stream<Object?> get errors => _errorController.stream;

  Future<void> loadData() async {
    _loadingController.add(true);
    try {
      final result = await _model.fetchData();
      _dataController.add(result);
      _errorController.add(null);
    } catch (error) {
      _errorController.add(error);
    } finally {
      _loadingController.add(false);
    }
  }
}
```

## 数据转换

### Model 到 UI 数据

```dart
class HomeViewModel extends BaseViewModel {
  Future<void> loadStudentInfo() async {
    try {
      // 获取原始数据
      final StudentInfoData data = await _model.fetchStudentInfo();

      // 转换为 UI 显示格式
      final displayText = "姓名：${data.name}\n学号：${data.userId}";
      _studentInfoController.add(displayText);
    } catch (error) {
      _studentErrorController.add(error);
    }
  }
}
```

### 列表数据处理

```dart
Future<void> loadCourseSchedule() async {
  try {
    final CourseScheduleData data = await _model.fetchCourseSchedule();
    final TimetableIndex index = const TimetableIndexBuilder().buildIndex(data);

    // 排序
    final entries = List<TimetableEntry>.from(index.allEntries)
      ..sort((a, b) {
        final dayA = a.dayOfWeek ?? 0;
        final dayB = b.dayOfWeek ?? 0;
        if (dayA != dayB) return dayA.compareTo(dayB);

        final startA = a.timeStart ?? 0;
        final startB = b.timeStart ?? 0;
        return startA.compareTo(startB);
      });

    _timetableController.add(entries);
  } catch (error) {
    _timetableErrorController.add(error);
  }
}
```

## 缓存处理

### 先缓存后网络

```dart
Future<void> loadSchoolCalendar() async {
  try {
    // 1. 先读取缓存
    final repo = SchoolCalendarRepository.getInstance();
    final cached = await repo.getSchoolCalendar();
    if (cached != null) {
      _schoolCalendarController.add(cached);
    }

    // 2. 再请求网络
    final data = await _model.fetchSchoolCalendar();
    await repo.saveSchoolCalendar(data);
    _schoolCalendarController.add(data);
  } catch (error) {
    _calendarErrorController.add(error);
  }
}
```

## 最佳实践

### 1. 单一职责

每个 ViewModel 只负责一个视图的逻辑：

```dart
// 好的做法
class LoginViewModel extends BaseViewModel { }
class HomeViewModel extends BaseViewModel { }
class SettingsViewModel extends BaseViewModel { }

// 不好的做法
class MainViewModel extends BaseViewModel {
  // 包含所有页面的逻辑...
}
```

### 2. 避免直接操作 UI

ViewModel 不应直接操作 UI 组件：

```dart
// 不好
class MyViewModel extends BaseViewModel {
  void showError() {
    ScaffoldMessenger.of(context).showSnackBar(...); // ❌
  }
}

// 好
class MyViewModel extends BaseViewModel {
  void sendErrorEvent() {
    _eventController.add(ShowSnackBarEvent(...)); // ✅
  }
}
```

### 3. 及时释放资源

```dart
@override
void dispose() {
  _dataController.close();
  _errorController.close();
  _eventController.close();
  super.dispose();
}
```

### 4. 使用异步方法

数据获取方法都应该是异步的：

```dart
// 好
Future<void> loadData() async { }

// 不好
void loadData() {
  _model.fetchData().then((data) { });
}
```

## 示例：完整的 ViewModel

```dart
class LoginViewModel extends BaseViewModel {
  LoginViewModel({LoginModel? model})
      : _model = model ?? LoginModel(),
        _eventController = StreamController<UiEvent>.broadcast();

  final LoginModel _model;
  final StreamController<UiEvent> _eventController;

  Stream<UiEvent> get events => _eventController.stream;

  Uri get authUri => _model.buildAuthUri();

  Future<NavigationActionPolicy> handleRedirectUri(
    InAppWebViewController controller,
    WebUri uri,
  ) async {
    try {
      final shouldNavigate = await _model.exchangeCodeIfRedirect(uri);
      if (shouldNavigate) {
        _eventController.add(const NavigateEvent(RoutePaths.home));
        return NavigationActionPolicy.CANCEL;
      }
      return NavigationActionPolicy.ALLOW;
    } on AppException catch (e) {
      _eventController.add(
        ShowSnackBarEvent(message: e.message, code: e.code),
      );
      return NavigationActionPolicy.CANCEL;
    }
  }

  @override
  void dispose() {
    _eventController.close();
    super.dispose();
  }
}
```
